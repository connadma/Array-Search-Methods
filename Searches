public class Searches {

    public static void main(String[] args) {
        int[] nums = {3, 11, 8, 2, 101, 99, 1, 2000};
        int[] nums2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        // call search methods here :)
    }

    public static int sequentialSearch(int[] loi, int num) {
        for (int i = 0; i < loi.length; i++) {
            if (loi[i] == num) {
                return i;
            }
        }
        return -1;
    }

    public static int sequentialSearch(String[] los, String target) {
        for (int i = 0; i < los.length; i++) {
            if (los[i].equals(target)) {
                return i;
            }
        }
        return -1;
    }

    //precondition: elements in aoi are in ascending order
    public static int binarySearch(int[] aoi, int target) {
        int min = 0;
        int max = aoi.length - 1;
        while (min <= max) {
            int mid = (min + max) / 2;
            if (aoi[mid] == target) {
                return mid;
            } else if (aoi[mid] < target) {
                min = mid + 1;
            } else {
                max = mid - 1;
            }
        }
        return -1;
    }

    //precondition: elements in aos are in alphabetical order
    public static int binarySearch(String[] aos, String target) {
        int min = 0;
        int max = aos.length - 1;
        while (min <= max) {
            int mid = (min + max) / 2;
            int result = aos[mid].compareTo(target);
            if (result == 0) {
                return mid;
            } else if (result < 0) {
                max = mid - 1;
            } else {
                min = mid + 1;
            }
        }
        return -1;
    }

    public static void insertionSort(int[] a) {
        int itemToInsert, j;
        boolean stillLooking;
        //on the kth pass insert k into its correct position among the first k entries
        for (int k = 1; k < a.length; k++) {
            itemToInsert = a[k];
            j = k - 1;
            stillLooking = true;
            while ((j >= 0) && stillLooking) {
                if (itemToInsert < a[j]) {
                    a[j + 1] = a[j];
                    j--;
                } else {
                    stillLooking = false;
                }
            }
            a[j + 1] = itemToInsert;
        }
    }


    // sorts the values in the array in ascending order
    public static void selectionSort(int[] a) {
        for (int i = 0; i < a.length - 1; i++) {
            int indexSmallest = i;
            for (int j = i + 1; j < a.length; j++) {
                if (a[j] < a[indexSmallest])
                    indexSmallest = j;
            }
            int temp = a[i];
            a[i] = a[indexSmallest];
            a[indexSmallest] = temp;
        }
    }
    
    //the two mergesort methods and the merge method are related to merge sorting
    public static void mergeSort(int[] a) {
        int[] copyBuffer = new int[a.length];
        mergeSort(a, copyBuffer, 0, a.length - 1);
    }

    private static void mergeSort(int[] a, int[] copyBuffer, int low, int high) {
        if (low < high) {
            int mid = (low + high) / 2;
            mergeSort(a, copyBuffer, low, mid); //sorts left half
            mergeSort(a, copyBuffer, mid + 1, high); //sorts right half
            merge(a, copyBuffer, low, mid, high);
        }
    }

    private static void merge(int[] a, int[] copyBuffer, int low, int mid, int high) {
        int i1 = low;
        int i2 = mid + 1;
        for (int i = low; i <= high; i++) {
            if (i1 > mid) { //left half is exhausted
                copyBuffer[i] = a[i2++];
            } else if (i2 > high) {
                copyBuffer[i] = a[i1++];
            } else if (a[i1] < a[i2]) {
                copyBuffer[i] = a[i1++];
            } else {
                copyBuffer[i] = a[i2++];
            }
        }
        for (int i = low; i <= high; i++) {
            a[i] = copyBuffer[i];
        }
    }
}
